#!/usr/bin/env python3
#
# Python script generated by Claude 3.7 Sonnet 2025-03-21
# This script reads in a PDB file and a text file that defines at least two regions
# It calculates the normal vector of each region, and then calculate the angle of each pair of regions
# It then generates a PyMOL visualization script .pml for showing the normal vectors, and color the regions
# It was created for analyzing the openness of multiple nucleosomes
#
# Example regions file
# REGION: bottom
# K 299 412
# S 152 264
# REGION: middle
# K 432 544
# S 10 131
# REGION: top
# K 153 278
# S 272 409

import numpy as np
import os
import sys
import itertools
from Bio.PDB import PDBParser, Selection, vectors

def read_region_definitions(region_file):
    """Read region definitions from a file."""
    regions = {}
    current_region = None
    
    with open(region_file, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
                
            if line.startswith('REGION:'):
                current_region = line.split(':', 1)[1].strip()
                regions[current_region] = []
            elif current_region and line[0] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                # Format: Chain ResidueStart ResidueEnd
                parts = line.split()
                if len(parts) == 3:
                    chain = parts[0]
                    start = int(parts[1])
                    end = int(parts[2])
                    regions[current_region].append((chain, start, end))
    
    return regions

def calculate_region_geometry(structure, region_def):
    """Calculate the normal vector and centroid for a region."""
    atom_coords = []
    
    for chain_id, start, end in region_def:
        for chain in structure.get_chains():
            if chain.id == chain_id:
                for residue in chain:
                    if residue.id[1] >= start and residue.id[1] <= end:
                        for atom in residue:
                            # Only use CA atoms for proteins or C1' for nucleic acids
                            if atom.name == 'CA' or atom.name == "C1'":
                                atom_coords.append(atom.coord)
    
    if not atom_coords:
        return None, None
        
    # Convert to numpy array
    points = np.array(atom_coords)
    
    # Calculate centroid
    centroid = np.mean(points, axis=0)
    
    # Calculate normal vector using SVD
    # Shift points to origin
    shifted_points = points - centroid
    
    # Singular Value Decomposition
    u, s, vh = np.linalg.svd(shifted_points, full_matrices=False)
    
    # The normal vector is the last row of vh
    normal_vector = vh[-1]
    
    # Normalize to unit length
    normal_vector = normal_vector / np.linalg.norm(normal_vector)
    
    return normal_vector, centroid

def calculate_angle(v1, v2):
    """Calculate the angle between two vectors in degrees."""
    dot_product = np.dot(v1, v2)
    # Clamp dot product to [-1, 1] to avoid numerical errors
    dot_product = max(min(dot_product, 1.0), -1.0)
    angle_rad = np.arccos(dot_product)
    angle_deg = np.degrees(angle_rad)
    return angle_deg

def calculate_all_angles(normals):
    """Calculate angles between all pairs of normal vectors."""
    angles = {}
    
    # Get all valid normal vectors
    valid_regions = {name: normal for name, normal in normals.items() if normal is not None}
    
    # Calculate angles between each pair
    for (name1, v1), (name2, v2) in itertools.combinations(valid_regions.items(), 2):
        angle = calculate_angle(v1, v2)
        angles[(name1, name2)] = angle
        
    return angles

def generate_pymol_script(pdb_file, regions, normals, centroids, angles, output_file="visualization.pml"):
    """Generate a PyMOL script for visualizing the structure and normal vectors."""
    with open(output_file, 'w') as f:
        # Load the PDB file
        f.write(f"load {pdb_file}, structure\n")
        
        # Basic display settings
        f.write("bg_color white\n")
        f.write("hide everything\n")
        f.write("show cartoon\n")
        f.write("color gray80, structure\n")
        
        # Define a list of distinct colors for different regions
        color_list = [
            "marine", "firebrick", "forest", "orange", "purple", 
            "cyan", "yellow", "magenta", "slate", "salmon", 
            "lime", "teal", "pink", "wheat", "lightblue"
        ]
        
        # Create a dynamic color mapping for each region
        colors = {}
        for i, region_name in enumerate(regions.keys()):
            colors[region_name] = color_list[i % len(color_list)]
        
        for region_name, region_def in regions.items():
            f.write(f"# Region: {region_name}\n")
            f.write(f"select {region_name}, ")
            
            selections = []
            for chain_id, start, end in region_def:
                selections.append(f"(chain {chain_id} and resi {start}-{end})")
            
            f.write(" or ".join(selections) + "\n")
            f.write(f"color {colors[region_name]}, {region_name}\n")
            f.write(f"show cartoon, {region_name}\n")
        
        # Add normal vectors using simple cylinders and cones
        for region_name, normal in normals.items():
            if normal is not None and centroids[region_name] is not None:
                centroid = centroids[region_name]
                # Make the arrow longer for better visibility (scale factor 30)
                end_point = centroid + normal * 30
                color = colors[region_name]
                
                # Create normal vector representation with simple PyMOL commands
                f.write(f"""
# Normal vector for {region_name}
pseudoatom center_{region_name}, pos=[{centroid[0]}, {centroid[1]}, {centroid[2]}]
pseudoatom end_{region_name}, pos=[{end_point[0]}, {end_point[1]}, {end_point[2]}]
distance normal_{region_name}, center_{region_name}, end_{region_name}
hide labels, normal_{region_name}
set dash_radius, 0.4, normal_{region_name}
set dash_gap, 0
color {color}, normal_{region_name}

# Add a cone at the end
cmd.load_cgo([
    9.0, {end_point[0]}, {end_point[1]}, {end_point[2]},
    {end_point[0] + normal[0]*5}, {end_point[1] + normal[1]*5}, {end_point[2] + normal[2]*5},
    1.0, 0.0
], 'cone_{region_name}')
cmd.color('{color}', 'cone_{region_name}')

# Group the normal vectors
cmd.group('normal_vector_{region_name}', 'center_{region_name} end_{region_name} normal_{region_name} cone_{region_name}')
cmd.group('normal_vectors', 'normal_vector_{region_name}')
                """)
        
        # Add labels for the regions and angles
        f.write("\n# Labels\n")
        for region_name, centroid in centroids.items():
            if centroid is not None:
                f.write(f"pseudoatom label_{region_name}, pos=[{centroid[0]}, {centroid[1]}, {centroid[2]}]\n")
                f.write(f"label label_{region_name}, '{region_name}'\n")
                f.write(f"set label_position, [5, 5, 5], label_{region_name}\n")
        
        # Group all labels
        f.write("group labels, label_*\n")
        
        # Display sequences using labels or representation
        f.write("\n# Sequence display settings\n")
        f.write("set seq_view, 1\n")  # Enable sequence view
        f.write("set seq_view_format, 1\n")  # One-letter code
        f.write("set seq_view_label_spacing, 2\n")  # Spacing
        
        # Final settings
        f.write("\n# Final display settings\n")
        f.write("zoom structure\n")
        f.write("set cartoon_transparency, 0.5\n")
        f.write("set ray_shadows, 0\n")
        f.write("set antialias, 2\n")
        f.write("set ray_trace_mode, 1\n")
        f.write("set surface_quality, 1\n")
        
        # Add angle measurements for all pairs
        if angles:
            f.write("\n# Angle measurements\n")
            
            # Create a group for angle markers
            f.write("group angle_markers\n")
            
            # Calculate positions for angle labels to avoid overlap
            y_offset = 0
            for (region1, region2), angle in angles.items():
                centroid1 = centroids[region1]
                centroid2 = centroids[region2]
                
                # Calculate midpoint between centroids
                midpoint = [(centroid1[0] + centroid2[0])/2, 
                           (centroid1[1] + centroid2[1])/2, 
                           (centroid1[2] + centroid2[2])/2]
                
                marker_name = f"angle_{region1}_{region2}"
                f.write(f"pseudoatom {marker_name}, pos=[{midpoint[0]}, {midpoint[1]}, {midpoint[2] + y_offset}]\n")
                f.write(f"label {marker_name}, 'Angle {region1}-{region2}: {angle:.2f}Â°'\n")
                f.write(f"set label_position, [0, 0, {10 + y_offset}], {marker_name}\n")
                f.write(f"set label_size, 14, {marker_name}\n")
                f.write(f"group angle_markers, {marker_name}\n")
                
                # Increment y_offset for next label
                y_offset += 5
        
        # Add a line to show the script is done loading and provide instructions
        f.write("""
# Print instructions
print("\\nNormal vectors visualization loaded successfully")
print("The following objects are available:")
print("  - structure: The loaded PDB structure")
print("  - normal_vectors: Group containing all normal vector representations")
print("  - labels: Group containing all region labels")
""")

        # Dynamically list the available regions
        f.write("print(\"  - Available regions: ")
        f.write(", ".join(regions.keys()))
        f.write("\")\n")

        # Print angle information if available
        if angles:
            f.write("print(\"\\nCalculated angles between normal vectors:\")\n")
            for (region1, region2), angle in angles.items():
                f.write(f"print(\"  - {region1} to {region2}: {angle:.2f} degrees\")\n")
            f.write("print(\"  (These are also displayed as labels in the 'angle_markers' group)\")\n")

        f.write("""
print("\\nTo adjust vector visibility, try commands like:")
print("  - set dash_radius, 0.8, normal_*")
print("  - set dash_color, marine, normal_*")
print("  - hide angle_markers # To hide all angle measurements")
print("  - show angle_markers # To show all angle measurements")
""")

def main():
    if len(sys.argv) < 3:
        print("Usage: python script.py <pdb_file> <region_file>")
        sys.exit(1)
    
    pdb_file = sys.argv[1]
    region_file = sys.argv[2]
    
    # Parse PDB file
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure("structure", pdb_file)
    
    # Read region definitions
    regions = read_region_definitions(region_file)
    
    # Calculate normal vectors and centroids for each region
    normals = {}
    centroids = {}
    
    print("\nCalculated geometry for defined regions:")
    for region_name, region_def in regions.items():
        normal, centroid = calculate_region_geometry(structure, region_def)
        normals[region_name] = normal
        centroids[region_name] = centroid
        
        if normal is not None and centroid is not None:
            print(f"\nRegion: {region_name}")
            print(f"  Normal vector: [{normal[0]:.4f}, {normal[1]:.4f}, {normal[2]:.4f}]")
            print(f"  Centroid: [{centroid[0]:.4f}, {centroid[1]:.4f}, {centroid[2]:.4f}]")
        else:
            print(f"\nRegion: {region_name} - Could not calculate geometry (no valid atoms found)")
    
    # Calculate angles between all pairs of normal vectors
    angles = calculate_all_angles(normals)
    
    # Print angle information
    if angles:
        print("\nAngles between normal vectors:")
        for (region1, region2), angle in angles.items():
            print(f"  {region1} to {region2}: {angle:.2f} degrees")
    else:
        print("\nCannot calculate angles: less than two valid normal vectors found")
    
    # Generate PyMOL script
    pymol_file = os.path.splitext(pdb_file)[0] + ".pml"
    generate_pymol_script(pdb_file, regions, normals, centroids, angles, pymol_file)
    print(f"\nPyMOL visualization script generated: {pymol_file}")
    print("Load this script in PyMOL to visualize the structure and normal vectors.")

if __name__ == "__main__":
    main()
